# ScheRubyGrammarLexer (ScheRubyGrammar.g)
# Generated by ANTLR 3.0.1 on 2008-01-13 22:11:14

class ScheRubyGrammarLexer
    require 'stringio'

	EOF=-1
	WS=13
	NUMBER=4
	STRING=9
	NIL=8
	FALSE=7
	SYMBOL=5
	RPAREN=11
	Tokens=15
	LPAREN=10
	COMMENT=14
	SINGLE_QUOTE=12
	TRUE=6
	
    def initialize(input)
        input = StringIO.new(input) if input.respond_to?(:to_str)
        @input = CharStream.new(input)
        @backtracking = 0
        @failed = false

    end

    def next_token
    	# TODO: catch exceptions
		@token = nil
		@channel = nil
		@text = nil

		@start = @input.index
		@line = @input.line
		@pos = @input.column

		@type = nil
		@type_int = nil

		return :EOF if @input.look_ahead(1) == :EOF

		match_Tokens()

		if @token == nil
			@text ||= @input.substring(@start, @input.index - 1)
			@token = Token.new(@type, @type_int, @line, @pos, @text, @channel)
		end

        return @token
    end

    class Token
        attr_reader :token_type
        attr_reader :int_type
        attr_reader :line
        attr_reader :pos
        attr_reader :text
        attr_reader :channel

        def initialize(token_type, int_type, line, pos, text, channel = nil)
            @token_type = token_type
            @int_type = int_type
            @line = line
            @pos = pos
            @text = text
            @channel = channel
        end

		alias :to_i :int_type
    end


    private

    class CharStream
        attr_reader :line
        attr_reader :column
        attr_reader :index

        def initialize(input)
            @buffer = ""
            @input = input
            @line = 1
            @column = 0

            @index = 0;
        end

        # returns a Fixnum between 0 and 0xFFFF or :EOF
        def look_ahead(pos)
            offset = @index + pos - 1
            if @buffer.length < offset + 1
                char = @input.read(offset + 1 - @buffer.length)
                @buffer << char if not char.nil?
            end

            if offset < @buffer.length
                @buffer[offset]
            else
                :EOF
            end
        end

        def mark
            @state = { :index => @index, :line => @line, :column => @column }
            return 0
        end

        def rewind(marker)
            @index = @state[:index]
            @line = @state[:line]
            @column = @state[:column]
        end

        def consume
           look_ahead(1) # force a read from the input if necessary
           @column = @column + 1
           if @buffer[@index] == ?\n
                @line = @line + 1
                @column = 0
           end
           @index = @index + 1
        end

        def substring(start, stop)
            @buffer.slice(start, stop - start + 1)
        end
    end


    def match(value = nil)
        @failed = false
        case
            when value.nil?
                @input.consume()
            when value.respond_to?(:to_str)
                catch(:done) do
                    value.each_byte do |c|
                        @failed ||= !(@input.look_ahead(1) == c)
                        @input.consume() if !@failed
                        throw :done if @failed
                    end
                end
            else
                @failed = !(@input.look_ahead(1) == value)
                @input.consume() if !@failed
        end

		if @failed && @backtracking <= 0
			raise "Expected #{value.respond_to?(:chr) ? value.chr : value}"
		end
    end

    def match_range(from, to)
        char = @input.look_ahead(1)

        if char != :EOF && (char >= from || char <= to)
			@failed = false
			match()
        elsif @backtracking > 0
            @failed = true
        else
            raise "Expected [#{from.chr}..#{to.chr}]"
        end
    end

    def match_SINGLE_QUOTE()

    		@type = :SINGLE_QUOTE
    		@type_int = SINGLE_QUOTE
    		# 80:16: '\\''
    		match(?\')
    end

    def match_LPAREN()

    		@type = :LPAREN
    		@type_int = LPAREN
    		# 81:10: '('
    		match(?()
    end

    def match_RPAREN()

    		@type = :RPAREN
    		@type_int = RPAREN
    		# 82:10: ')'
    		match(?))
    end

    def match_WS()

    		@type = :WS
    		@type_int = WS
    		# 83:6: ( ' ' | '\\t' | '\\r' | '\\n' )+
    		# 83:6: ( ' ' | '\\t' | '\\r' | '\\n' )+
    		matchedOnce1 = false
    		while true
    		    alt1 = 2
    		    # ()+ loopback of 83:6: ( ' ' | '\\t' | '\\r' | '\\n' )+
    		    look_ahead1_0 = @input.look_ahead(1)
    		    look_ahead1_0 = -1 if look_ahead1_0 == :EOF
    		    if (look_ahead1_0 >= ?\t && look_ahead1_0 <= ?\n) || look_ahead1_0 == ?\r || look_ahead1_0 == ?\s  
    		        alt1 = 1
    		    end
    		    case alt1
    		        when 1
    		            # 
    		            if (@input.look_ahead(1) >= ?\t && @input.look_ahead(1) <= ?\n) || @input.look_ahead(1) == ?\r || @input.look_ahead(1) == ?\s
    		                match()
    		            else
    		                raise "Expected set"
    		            end
    		        else
    		            break
    		    end
    		    matchedOnce1 = true
    		end

    		if !matchedOnce1
    		    raise "Expected at least one match: 83:6: ( ' ' | '\\t' | '\\r' | '\\n' )+"
    		end
    		@channel = 99 # HIDDEN 
    end

    def match_COMMENT()

    		@type = :COMMENT
    		@type_int = COMMENT
    		# 84:11: ';' (~ ( '\\r' | '\\n' ) )*
    		match(?;)
    		# 84:15: (~ ( '\\r' | '\\n' ) )*
    		while true
    		    alt2 = 2
    		    # ()* loopback of 84:15: (~ ( '\\r' | '\\n' ) )*
    		    look_ahead2_0 = @input.look_ahead(1)
    		    look_ahead2_0 = -1 if look_ahead2_0 == :EOF
    		    if (look_ahead2_0 >= 0x0000 && look_ahead2_0 <= ?\t) || (look_ahead2_0 >= 0x000B && look_ahead2_0 <= ?\f) || (look_ahead2_0 >= 0x000E && look_ahead2_0 <= 0x00FF)  
    		        alt2 = 1
    		    end
    		    case alt2
    		        when 1
    		            # 84:15: ~ ( '\\r' | '\\n' )
    		            if (@input.look_ahead(1) >= 0x0000 && @input.look_ahead(1) <= ?\t) || (@input.look_ahead(1) >= 0x000B && @input.look_ahead(1) <= ?\f) || (@input.look_ahead(1) >= 0x000E && @input.look_ahead(1) <= 0x00FF)
    		                match()
    		            else
    		                raise "Expected set"
    		            end
    		        else
    		            break
    		    end
    		end
    		@channel = 99 # HIDDEN 
    end

    def match_SYMBOL()

    		@type = :SYMBOL
    		@type_int = SYMBOL
    		# 101:10: ( '.' | '::' | '@' )? ( 'a' .. 'z' | 'A' .. 'Z' | '-' | '%' | '^' | '&' | '*' | '_' | '+' | '=' | '/' | '<' | '>' | '?' | '!' | '[' | ']' | '$' | '~' ) ( '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' | '-' | '%' | '^' | '&' | '*' | '_' | '+' | '=' | '/' | '<' | '>' | '?' | '!' | '[' | ']' | '::' | '@' )*
    		# 101:10: ( '.' | '::' | '@' )?
    		alt3 = 4
    		# 101:10: ( '.' | '::' | '@' )?
    		case @input.look_ahead(1)
    		    when ?.
    		        alt3 = 1
    		    when ?:
    		        alt3 = 2
    		    when ?@
    		        alt3 = 3
    		end
    		case alt3
    		    when 1
    		        # 101:11: '.'
    		        match(?.)
    		    when 2
    		        # 101:15: '::'
    		        match("::")

    		    when 3
    		        # 101:20: '@'
    		        match(?@)
    		end
    		if @input.look_ahead(1) == ?! || (@input.look_ahead(1) >= ?$ && @input.look_ahead(1) <= ?&) || (@input.look_ahead(1) >= ?* && @input.look_ahead(1) <= ?+) || @input.look_ahead(1) == ?- || @input.look_ahead(1) == ?/ || (@input.look_ahead(1) >= ?< && @input.look_ahead(1) <= ??) || (@input.look_ahead(1) >= ?A && @input.look_ahead(1) <= ?[) || (@input.look_ahead(1) >= ?] && @input.look_ahead(1) <= ?_) || (@input.look_ahead(1) >= ?a && @input.look_ahead(1) <= ?z) || @input.look_ahead(1) == ?~
    		    match()
    		else
    		    raise "Expected set"
    		end
    		# 101:112: ( '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' | '-' | '%' | '^' | '&' | '*' | '_' | '+' | '=' | '/' | '<' | '>' | '?' | '!' | '[' | ']' | '::' | '@' )*
    		while true
    		    alt4 = 21
    		    # ()* loopback of 101:112: ( '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' | '-' | '%' | '^' | '&' | '*' | '_' | '+' | '=' | '/' | '<' | '>' | '?' | '!' | '[' | ']' | '::' | '@' )*
    		    case @input.look_ahead(1)
    		        when ?0,?1,?2,?3,?4,?5,?6,?7,?8,?9
    		            alt4 = 1
    		        when ?a,?b,?c,?d,?e,?f,?g,?h,?i,?j,?k,?l,?m,?n,?o,?p,?q,?r,?s,?t,?u,?v,?w,?x,?y,?z
    		            alt4 = 2
    		        when ?A,?B,?C,?D,?E,?F,?G,?H,?I,?J,?K,?L,?M,?N,?O,?P,?Q,?R,?S,?T,?U,?V,?W,?X,?Y,?Z
    		            alt4 = 3
    		        when ?-
    		            alt4 = 4
    		        when ?%
    		            alt4 = 5
    		        when ?^
    		            alt4 = 6
    		        when ?&
    		            alt4 = 7
    		        when ?*
    		            alt4 = 8
    		        when ?_
    		            alt4 = 9
    		        when ?+
    		            alt4 = 10
    		        when ?=
    		            alt4 = 11
    		        when ?/
    		            alt4 = 12
    		        when ?<
    		            alt4 = 13
    		        when ?>
    		            alt4 = 14
    		        when ??
    		            alt4 = 15
    		        when ?!
    		            alt4 = 16
    		        when ?[
    		            alt4 = 17
    		        when ?]
    		            alt4 = 18
    		        when ?:
    		            alt4 = 19
    		        when ?@
    		            alt4 = 20
    		    end
    		    case alt4
    		        when 1
    		            # 101:113: '0' .. '9'
    		            match_range(?0, ?9)
    		        when 2
    		            # 101:122: 'a' .. 'z'
    		            match_range(?a, ?z)
    		        when 3
    		            # 101:131: 'A' .. 'Z'
    		            match_range(?A, ?Z)
    		        when 4
    		            # 101:140: '-'
    		            match(?-)
    		        when 5
    		            # 101:144: '%'
    		            match(?%)
    		        when 6
    		            # 101:148: '^'
    		            match(?^)
    		        when 7
    		            # 101:152: '&'
    		            match(?&)
    		        when 8
    		            # 101:156: '*'
    		            match(?*)
    		        when 9
    		            # 101:160: '_'
    		            match(?_)
    		        when 10
    		            # 101:164: '+'
    		            match(?+)
    		        when 11
    		            # 101:168: '='
    		            match(?=)
    		        when 12
    		            # 101:172: '/'
    		            match(?/)
    		        when 13
    		            # 101:176: '<'
    		            match(?<)
    		        when 14
    		            # 101:180: '>'
    		            match(?>)
    		        when 15
    		            # 101:184: '?'
    		            match(??)
    		        when 16
    		            # 101:188: '!'
    		            match(?!)
    		        when 17
    		            # 101:192: '['
    		            match(?[)
    		        when 18
    		            # 101:196: ']'
    		            match(?])
    		        when 19
    		            # 101:200: '::'
    		            match("::")

    		        when 20
    		            # 101:205: '@'
    		            match(?@)
    		        else
    		            break
    		    end
    		end
    end

    def match_TRUE()

    		@type = :TRUE
    		@type_int = TRUE
    		# 105:10: '#t'
    		match("#t")

    end

    def match_FALSE()

    		@type = :FALSE
    		@type_int = FALSE
    		# 106:9: '#f'
    		match("#f")

    end

    def match_NIL()

    		@type = :NIL
    		@type_int = NIL
    		# 108:8: '#nil'
    		match("#nil")

    end

    def match_STRING()

    		@type = :STRING
    		@type_int = STRING
    		# 122:10: '\"' (~ ( '\\\\' | '\"' ) | ( '\\\\' . ) )* '\"'
    		match(?")
    		# 122:14: (~ ( '\\\\' | '\"' ) | ( '\\\\' . ) )*
    		while true
    		    alt5 = 3
    		    # ()* loopback of 122:14: (~ ( '\\\\' | '\"' ) | ( '\\\\' . ) )*
    		    look_ahead5_0 = @input.look_ahead(1)
    		    look_ahead5_0 = -1 if look_ahead5_0 == :EOF
    		    if (look_ahead5_0 >= 0x0000 && look_ahead5_0 <= ?!) || (look_ahead5_0 >= ?# && look_ahead5_0 <= ?[) || (look_ahead5_0 >= ?] && look_ahead5_0 <= 0x00FF)  
    		        alt5 = 1
    		    elsif look_ahead5_0 == ?\\  
    		        alt5 = 2
    		    end
    		    case alt5
    		        when 1
    		            # 122:16: ~ ( '\\\\' | '\"' )
    		            if (@input.look_ahead(1) >= 0x0000 && @input.look_ahead(1) <= ?!) || (@input.look_ahead(1) >= ?# && @input.look_ahead(1) <= ?[) || (@input.look_ahead(1) >= ?] && @input.look_ahead(1) <= 0x00FF)
    		                match()
    		            else
    		                raise "Expected set"
    		            end
    		        when 2
    		            # 122:28: ( '\\\\' . )
    		            # 122:29: '\\\\' .
    		            match(?\\)
    		            match()
    		        else
    		            break
    		    end
    		end
    		match(?")
    end

    def match_NUMBER()

    		@type = :NUMBER
    		@type_int = NUMBER
    		# 166:11: ( '-' )? ( ( '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ ) | ( '0' .. '9' ) ( '0' .. '9' | '.' )* )
    		# 166:11: ( '-' )?
    		alt6 = 2
    		# 166:11: ( '-' )?
    		look_ahead6_0 = @input.look_ahead(1)

    		look_ahead6_0 = -1 if look_ahead6_0 == :EOF
    		if look_ahead6_0 == ?-  
    		    alt6 = 1
    		end
    		case alt6
    		    when 1
    		        # 166:11: '-'
    		        match(?-)
    		end
    		# 166:15: ( ( '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ ) | ( '0' .. '9' ) ( '0' .. '9' | '.' )* )
    		alt9 = 2
    		# 166:15: ( ( '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ ) | ( '0' .. '9' ) ( '0' .. '9' | '.' )* )
    		look_ahead9_0 = @input.look_ahead(1)
    		look_ahead9_0 = -1 if look_ahead9_0 == :EOF
    		if look_ahead9_0 == ?0  
    		    # 166:15: ( ( '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ ) | ( '0' .. '9' ) ( '0' .. '9' | '.' )* )
    		    look_ahead9_1 = @input.look_ahead(2)
    		    look_ahead9_1 = -1 if look_ahead9_1 == :EOF
    		    if look_ahead9_1 == ?x  
    		        alt9 = 1
    		    else
    		        alt9 = 2
    		    end
    		elsif (look_ahead9_0 >= ?1 && look_ahead9_0 <= ?9)  
    		    alt9 = 2
    		else
    		    raise "Expected: 166:15: ( ( '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ ) | ( '0' .. '9' ) ( '0' .. '9' | '.' )* )"
    		end
    		case alt9
    		    when 1
    		        # 166:16: ( '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ )
    		        # 166:17: '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
    		        match("0x")

    		        # 166:21: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
    		        matchedOnce7 = false
    		        while true
    		            alt7 = 2
    		            # ()+ loopback of 166:21: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
    		            look_ahead7_0 = @input.look_ahead(1)
    		            look_ahead7_0 = -1 if look_ahead7_0 == :EOF
    		            if (look_ahead7_0 >= ?0 && look_ahead7_0 <= ?9) || (look_ahead7_0 >= ?A && look_ahead7_0 <= ?F) || (look_ahead7_0 >= ?a && look_ahead7_0 <= ?f)  
    		                alt7 = 1
    		            end
    		            case alt7
    		                when 1
    		                    # 
    		                    if (@input.look_ahead(1) >= ?0 && @input.look_ahead(1) <= ?9) || (@input.look_ahead(1) >= ?A && @input.look_ahead(1) <= ?F) || (@input.look_ahead(1) >= ?a && @input.look_ahead(1) <= ?f)
    		                        match()
    		                    else
    		                        raise "Expected set"
    		                    end
    		                else
    		                    break
    		            end
    		            matchedOnce7 = true
    		        end

    		        if !matchedOnce7
    		            raise "Expected at least one match: 166:21: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+"
    		        end
    		    when 2
    		        # 166:52: ( '0' .. '9' ) ( '0' .. '9' | '.' )*
    		        # 166:53: '0' .. '9'
    		        match_range(?0, ?9)
    		        # 166:62: ( '0' .. '9' | '.' )*
    		        while true
    		            alt8 = 2
    		            # ()* loopback of 166:62: ( '0' .. '9' | '.' )*
    		            look_ahead8_0 = @input.look_ahead(1)
    		            look_ahead8_0 = -1 if look_ahead8_0 == :EOF
    		            if look_ahead8_0 == ?. || (look_ahead8_0 >= ?0 && look_ahead8_0 <= ?9)  
    		                alt8 = 1
    		            end
    		            case alt8
    		                when 1
    		                    # 
    		                    if @input.look_ahead(1) == ?. || (@input.look_ahead(1) >= ?0 && @input.look_ahead(1) <= ?9)
    		                        match()
    		                    else
    		                        raise "Expected set"
    		                    end
    		                else
    		                    break
    		            end
    		        end
    		end
    end

    def match_Tokens()

    		# 1:8: ( SINGLE_QUOTE | LPAREN | RPAREN | WS | COMMENT | SYMBOL | TRUE | FALSE | NIL | STRING | NUMBER )
    		alt10 = 11
    		alt10 = DFA10.predict(self, @input)
    		case alt10
    		    when 1
    		        # 1:10: SINGLE_QUOTE
    		        match_SINGLE_QUOTE()
    		    when 2
    		        # 1:23: LPAREN
    		        match_LPAREN()
    		    when 3
    		        # 1:30: RPAREN
    		        match_RPAREN()
    		    when 4
    		        # 1:37: WS
    		        match_WS()
    		    when 5
    		        # 1:40: COMMENT
    		        match_COMMENT()
    		    when 6
    		        # 1:48: SYMBOL
    		        match_SYMBOL()
    		    when 7
    		        # 1:55: TRUE
    		        match_TRUE()
    		    when 8
    		        # 1:60: FALSE
    		        match_FALSE()
    		    when 9
    		        # 1:66: NIL
    		        match_NIL()
    		    when 10
    		        # 1:70: STRING
    		        match_STRING()
    		    when 11
    		        # 1:77: NUMBER
    		        match_NUMBER()
    		end

    end


	    class DFA
	        def initialize(eot, eof, min, max, accept, special, transition)
	            @eot = eot
	            @eof = eof
	            @min = min
	            @max = max
	            @accept = accept
	            @special = special
	            @transition = transition
	        end

	        def predict(parser, input)
	            mark = input.mark()
	            s = 0 # we always start at s0
	            begin
	                loop do
	                    special_state = @special[s]
	                    if special_state >= 0
	                        s = parser.special_state_transition(special_state)
	                        input.consume()
	                        next
	                    end

	                    if @accept[s] >= 1
	                        return @accept[s]
	                    end

	                    # look for a normal char transition
	                    c = input.look_ahead(1).to_i
	                    if c != :EOF && c >= @min[s] && c <= @max[s]
	                        next_state = @transition[s][c - @min[s]] # move to next state
	                        if next_state < 0
	                            # was in range but not a normal transition
	                            # must check EOT, which is like the else clause.
	                            # eot[s]>=0 indicates that an EOT edge goes to another
	                            # state.
	                            if @eot[s] >= 0  # EOT Transition to accept state?
	                                s = @eot[s]
	                                input.consume()
	                                next
	                            end
	                            raise "No viable alt"
	                        end
	                        s = next_state
	                        input.consume()
	                        next
	                    end
	                    if @eot[s] >= 0   # EOT Transition?
	                        s = @eot[s]
	                        input.consume()
	                        next
	                    end
	                    if c == :EOF && @eof[s] >= 0   # EOF Transition to accept state?
	                        return @accept[@eof[s]]
	                    end

	                    # not in range and not EOF/EOT, must be invalid symbol
	                    raise "No viable alt"
	                end
	            ensure
	                input.rewind(mark)
	            end
	        end
	    end

    DFA10 = DFA.new(
        [-1,-1,-1,-1,-1,-1,-1,6,-1,-1,-1,6,6,-1,-1,-1,6,6,6,6,6],
        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
        [9,0,0,0,0,0,0,48,102,0,0,46,46,0,0,0,48,46,48,48,48],
        [126,0,0,0,0,0,0,57,116,0,0,120,57,0,0,0,102,57,102,102,102],
        [-1,1,2,3,4,5,6,-1,-1,10,11,-1,-1,8,9,7,-1,-1,-1,-1,-1],
        [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
        [
            [4,4,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 -1,-1,4,6,9,8,6,6,6,1,2,3,6,6,-1,7,6,6,10,10,10,10,10,10,
                 10,10,10,10,6,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
                 6,6,6,6,6,6,6,6,6,6,6,6,-1,6,6,6,-1,6,6,6,6,6,6,6,6,6,6,
                 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,-1,-1,-1,6],
            [],
            [],
            [],
            [],
            [],
            [],
            [11,12,12,12,12,12,12,12,12,12],
            [13,-1,-1,-1,-1,-1,-1,-1,14,-1,-1,-1,-1,-1,15],
            [],
            [],
            [10,-1,17,17,17,17,17,17,17,17,17,17,-1,-1,-1,-1,-1,-1,-1,-1,
                 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,16],
            [10,-1,17,17,17,17,17,17,17,17,17,17],
            [],
            [],
            [],
            [18,18,18,18,18,18,18,18,18,18,-1,-1,-1,-1,-1,-1,-1,20,20,20,
                 20,20,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,19,19,19,19,19],
            [10,-1,17,17,17,17,17,17,17,17,17,17],
            [18,18,18,18,18,18,18,18,18,18,-1,-1,-1,-1,-1,-1,-1,20,20,20,
                 20,20,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,19,19,19,19,19],
            [18,18,18,18,18,18,18,18,18,18,-1,-1,-1,-1,-1,-1,-1,20,20,20,
                 20,20,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,19,19,19,19,19],
            [18,18,18,18,18,18,18,18,18,18,-1,-1,-1,-1,-1,-1,-1,20,20,20,
                 20,20,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,19,19,19,19,19]
        ])

    def special_state_transition(s)
    		-1
    end

    public :special_state_transition
end