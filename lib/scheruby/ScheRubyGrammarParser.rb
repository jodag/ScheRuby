# ScheRubyGrammarParser (ScheRubyGrammar.g)
# Generated by ANTLR 3.0.1 on 2008-01-13 22:11:14

require 'yaml'
require 'scheruby/ScheRubyGrammarLexer'

class ScheRubyGrammarParser
	attr_reader :lexer
	
    TOKENS = [
        ["NUMBER", 1],
        ["SYMBOL", 2],
        ["TRUE", 3],
        ["FALSE", 4],
        ["NIL", 5],
        ["STRING", 6],
        ["LPAREN", 7],
        ["RPAREN", 8],
        ["SINGLE_QUOTE", 9],
        ["WS", 10],
        ["COMMENT", 11]
    ].inject({}) { |hash, pair|
        name = pair[0]
        index = pair[1] + 3 # hardcoded for now... no way to get this value from ANTLR

        if name[0] == ?'
            hash[:"T#{index}"] = index
        else
            hash[:"#{name}"] = index
        end

        hash
    }
    
    TOKENS[:EOF] = -1

    def initialize(input)
        if input.respond_to?(:to_str) || input.respond_to?(:read)
            input = ScheRubyGrammarLexer.new(input)
        end

		@lexer = input
        @input = TokenStream.new(input)
        @backtracking = 0
        @failed = false


    end

    # 28:1: datums returns [val] : ( datum )+ ;
    def datums()
    	 _retval_val = nil 



        # 29:4: ( datum )+
         	_retval_val = Cons::EMPTY_LIST 
        # 30:3: ( datum )+
        matchedOnce1 = false
        while true
            alt1 = 2
            # ()+ loopback of 30:3: ( datum )+
            look_ahead1_0 = look_ahead(1)
            if (TOKENS[look_ahead1_0] >= 4 && TOKENS[look_ahead1_0] <= 10) || look_ahead1_0 == :SINGLE_QUOTE  
                alt1 = 1
            end
            case alt1
                when 1
                    # 30:4: datum
                    _datum1 = datum()

                     	_retval_val = Cons.adjoin!(	_retval_val, _datum1) 
                else
                    break
            end
            matchedOnce1 = true
        end

        if !matchedOnce1
            raise "Expected at least one match: 30:3: ( datum )+"
        end



        return _retval_val
    end

    # 48:1: datum returns [val] : ( atom | list );
    def datum()
    	 _retval_val = nil 



        # 49:2: ( atom | list )
        alt2 = 2
        # 48:1: datum returns [val] : ( atom | list );
        look_ahead2_0 = look_ahead(1)
        if (TOKENS[look_ahead2_0] >= 4 && TOKENS[look_ahead2_0] <= 9)  
            alt2 = 1
        elsif look_ahead2_0 == :LPAREN || look_ahead2_0 == :SINGLE_QUOTE  
            alt2 = 2
        else
            raise "Expected: 48:1: datum returns [val] : ( atom | list );"
        end
        case alt2
            when 1
                # 49:4: atom
                _atom2 = atom()

                 	_retval_val = _atom2 
            when 2
                # 50:4: list
                _list3 = list()

                 	_retval_val = _list3 
        end



        return _retval_val
    end

    # 53:1: atom returns [val] : ( NUMBER | SYMBOL | TRUE | FALSE | NIL | STRING );
    def atom()
    	 _retval_val = nil 
    	_NUMBER4 = nil
    	_SYMBOL5 = nil
    	_STRING6 = nil




        # 54:2: ( NUMBER | SYMBOL | TRUE | FALSE | NIL | STRING )
        alt3 = 6
        # 53:1: atom returns [val] : ( NUMBER | SYMBOL | TRUE | FALSE | NIL | STRING );
        case look_ahead(1)
            when :NUMBER
                alt3 = 1
            when :SYMBOL
                alt3 = 2
            when :TRUE
                alt3 = 3
            when :FALSE
                alt3 = 4
            when :NIL
                alt3 = 5
            when :STRING
                alt3 = 6
            else
                raise "Expected: 53:1: atom returns [val] : ( NUMBER | SYMBOL | TRUE | FALSE | NIL | STRING );"

        end
        case alt3
            when 1
                # 54:4: NUMBER
                _NUMBER4 = @input.look_ahead(1)
                match(:NUMBER)
                 	_retval_val = YAML::load(_NUMBER4.text) 
            when 2
                # 55:4: SYMBOL
                _SYMBOL5 = @input.look_ahead(1)
                match(:SYMBOL)
                 	_retval_val = _SYMBOL5.text.to_sym 
            when 3
                # 56:4: TRUE
                match(:TRUE)
                 	_retval_val = true 
            when 4
                # 57:4: FALSE
                match(:FALSE)
                 	_retval_val = false 
            when 5
                # 58:4: NIL
                match(:NIL)
                 	_retval_val = nil 
            when 6
                # 59:4: STRING
                _STRING6 = @input.look_ahead(1)
                match(:STRING)
                 	_retval_val = YAML::load(_STRING6.text) 
        end



        return _retval_val
    end

    # 62:1: list returns [val] : ( LPAREN ( datum )* RPAREN | SINGLE_QUOTE datum );
    def list()
    	 _retval_val = nil 



        # 63:2: ( LPAREN ( datum )* RPAREN | SINGLE_QUOTE datum )
        alt5 = 2
        # 62:1: list returns [val] : ( LPAREN ( datum )* RPAREN | SINGLE_QUOTE datum );
        look_ahead5_0 = look_ahead(1)
        if look_ahead5_0 == :LPAREN  
            alt5 = 1
        elsif look_ahead5_0 == :SINGLE_QUOTE  
            alt5 = 2
        else
            raise "Expected: 62:1: list returns [val] : ( LPAREN ( datum )* RPAREN | SINGLE_QUOTE datum );"
        end
        case alt5
            when 1
                # 63:4: LPAREN ( datum )* RPAREN
                 	_retval_val = Cons::EMPTY_LIST 
                match(:LPAREN)
                # 64:10: ( datum )*
                while true
                    alt4 = 2
                    # ()* loopback of 64:10: ( datum )*
                    look_ahead4_0 = look_ahead(1)
                    if (TOKENS[look_ahead4_0] >= 4 && TOKENS[look_ahead4_0] <= 10) || look_ahead4_0 == :SINGLE_QUOTE  
                        alt4 = 1
                    end
                    case alt4
                        when 1
                            # 64:11: datum
                            _datum7 = datum()

                             	_retval_val = Cons.adjoin!(	_retval_val, _datum7) 
                        else
                            break
                    end
                end
                match(:RPAREN)
            when 2
                # 66:3: SINGLE_QUOTE datum
                match(:SINGLE_QUOTE)
                _datum8 = datum()

                 	_retval_val = Cons.list(:quote, _datum8) 
        end



        return _retval_val
    end


    private

    class TokenStream
        attr_reader :index

        def initialize(input)
            @buffer = []
            @input = input
            @channel = nil

            @index = 0;
        end

        # returns a Token
        def look_ahead(pos)
            offset = @index + pos - 1

            while @buffer[-1] != :EOF && @buffer.length < offset + 1
                token = @input.next_token
                if token == :EOF || token.channel == @channel
                    @buffer << token
                end
            end

            offset = -1 if offset >= @buffer.length
            if offset < @buffer.length
                @buffer[offset]
            end
        end

        def mark
            @state = { :index => @index }
            return 0
        end

        def rewind(marker)
            @index = @state[:index]
        end

        def consume
           look_ahead(1) # force a read from the input if necessary
           @index = @index + 1
        end
    end

    def match(token = nil)
        if token.nil? || look_ahead(1) == token
            @input.consume
            @failed = false
            return
        elsif @backtracking > 0
            @failed = true
        else
            raise "Expected #{token}"
        end
    end

    def look_ahead(k)
        token = @input.look_ahead(k)
        if token != :EOF
            token = token.token_type
        end

        token
    end


end